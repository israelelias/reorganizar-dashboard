(() => {
  /**
   * ============================================
   * 🚀 Snippet utilitário de reorganização visual
   * Autor: israel elias
   * Versão: 3.0
   * Compatível com: Edge / Chrome / Firefox
   * ============================================
   * 
   * ATUALIZAÇÃO v3.0:
   * - Sistema de toggle (alternar entre estados)
   * - Atalho de teclado personalizável
   * - Restauração sem reload da página
   * - Preservação completa do estado original
   */

  /** --------------------------
   * ⚙️ CONFIGURAÇÕES GERAIS
   * ---------------------------*/
  const config = {
    // Atalho de teclado (personalizável)
    // Formato: { ctrl: true, alt: false, shift: false, key: 'Q' }
    keyboard: {
      ctrl: true,
      alt: false,
      shift: false,
      key: 'Q'  // Ctrl+Q - Fácil de pressionar e não conflita com atalhos comuns
    },

    // Se true → remove elementos do DOM
    // Se false → apenas oculta via CSS
    removeElements: false,

    selectorsToHideOrRemove: [
      '.section.priorities-section',
      '.content-right-top'
    ],

    // CSS adicional que será injetado
    customCSS: `
      .growl-container {
        visibility: hidden !important;
      }

      .content-fixed.content-left {
        top: 55px;
        bottom: 0;
        left: 0;
        width: 210px;
      }

      .content-fixed.content-center-top {
        position: absolute;
        top: 55px;
        left: 210px;
        bottom: 0;
        right: 210px;
        width: 420px;
        padding: 0 5px;
      }

      .content-fixed.content-right {
        position: absolute;
        top: 55px;
        bottom: 0;
        right: 0;
        width: calc(100% - 630px);
      }

      /* Listas de ocorrências - Layout otimizado */
      .occurrence-list.open-list {
        position: absolute;
        top: 0;
        bottom: 0;
        left: 212px;
        width: 207px;
      }

      .occurrence-list.attendance-list {
        position: relative;
        top: 0;
        right: 0;
        width: 207px;
        height: 49.5%;
      }

      .occurrence-list.hold-list {
        position: relative;
        bottom: 0;
        right: 0;
        width: 207px;
        height: 49.5%;
      }
    `
  };

  /** --------------------------
   * 💾 ARMAZENAMENTO DE ESTADO
   * ---------------------------*/
  const state = {
    isModified: false,
    styleElement: null,
    originalState: {
      elements: new Map(),
      hiddenElements: []
    }
  };

  /** --------------------------
   * 🔧 FUNÇÕES DE UTILIDADE
   * ---------------------------*/

  const $ = (selector) => document.querySelector(selector);
  const $$ = (selector) => document.querySelectorAll(selector);

  /**
   * Salva o estado original dos elementos
   */
  const saveOriginalState = () => {
    console.log('💾 Salvando estado original...');
    
    const contentLeft = $('.content-fixed.content-left');
    const contentCenterTop = $('.content-fixed.content-center-top');
    const contentRight = $('.content-fixed.content-right');

    if (!contentLeft || !contentCenterTop || !contentRight) {
      console.error('❌ Elementos principais não encontrados.');
      return false;
    }

    // Salva estrutura completa de cada container
    state.originalState.elements.set('left', {
      element: contentLeft,
      children: Array.from(contentLeft.children),
      classes: Array.from(contentLeft.classList),
      ngClass: contentLeft.getAttribute('ng-class')
    });

    state.originalState.elements.set('center', {
      element: contentCenterTop,
      children: Array.from(contentCenterTop.children),
      classes: Array.from(contentCenterTop.classList),
      ngClass: contentCenterTop.getAttribute('ng-class')
    });

    state.originalState.elements.set('right', {
      element: contentRight,
      children: Array.from(contentRight.children),
      classes: Array.from(contentRight.classList),
      ngClass: contentRight.getAttribute('ng-class')
    });

    console.log('✅ Estado original salvo.');
    return true;
  };

  /**
   * Atualiza a classe de posicionamento de um elemento
   */
  const updatePositionClass = (element, oldClass, newClass) => {
    if (!element) return;
    
    element.classList.remove(oldClass);
    element.classList.add(newClass);
    
    const ngClass = element.getAttribute('ng-class');
    if (ngClass) {
      const updated = ngClass.replace(
        new RegExp(`content-${oldClass.split('-').pop()}`, 'g'),
        `content-${newClass.split('-').pop()}`
      );
      element.setAttribute('ng-class', updated);
    }
    
    console.log(`🔄 Classe atualizada: ${oldClass} → ${newClass}`);
  };

  /**
   * Oculta ou remove elementos do DOM
   */
  const hideOrRemoveElements = () => {
    config.selectorsToHideOrRemove.forEach((sel) => {
      $$(sel).forEach((el) => {
        // Salva referência para restauração
        if (!state.originalState.hiddenElements.includes(el)) {
          state.originalState.hiddenElements.push({
            element: el,
            display: el.style.display,
            visibility: el.style.visibility
          });
        }

        if (config.removeElements) {
          el.remove();
          console.log(`🗑️ Removido: ${sel}`);
        } else {
          el.style.visibility = 'hidden';
          el.style.display = 'none';
          console.log(`🙈 Ocultado: ${sel}`);
        }
      });
    });
  };

  /**
   * Restaura elementos ocultos
   */
  const restoreHiddenElements = () => {
    state.originalState.hiddenElements.forEach(({ element, display, visibility }) => {
      element.style.display = display;
      element.style.visibility = visibility;
    });
    state.originalState.hiddenElements = [];
    console.log('👁️ Elementos ocultos restaurados.');
  };

  /**
   * Injeta CSS customizado no head
   */
  const injectCustomCSS = () => {
    const styleId = 'dashboard-reorganizer-styles';
    
    const existingStyle = $(`#${styleId}`);
    if (existingStyle) {
      existingStyle.remove();
    }
    
    const style = document.createElement('style');
    style.id = styleId;
    style.textContent = config.customCSS.trim();
    document.head.appendChild(style);
    state.styleElement = style;
    console.log('🎨 CSS personalizado injetado.');
  };

  /**
   * Remove CSS customizado
   */
  const removeCustomCSS = () => {
    if (state.styleElement) {
      state.styleElement.remove();
      state.styleElement = null;
      console.log('🎨 CSS personalizado removido.');
    }
  };

  /**
   * Valida a presença das listas de ocorrências
   */
  const validateOccurrenceLists = () => {
    const lists = {
      open: $('.occurrence-list.open-list'),
      attendance: $('.occurrence-list.attendance-list'),
      hold: $('.occurrence-list.hold-list')
    };

    const found = Object.entries(lists)
      .filter(([, el]) => el !== null)
      .map(([name]) => name);

    if (found.length > 0) {
      console.log(`📋 Listas de ocorrências encontradas: ${found.join(', ')}`);
    } else {
      console.log('ℹ️ Nenhuma lista de ocorrências detectada.');
    }

    return lists;
  };

  /**
   * Reorganiza as listas de ocorrências
   */
  const reorderOccurrenceLists = () => {
    console.log('🔀 Reorganizando ordem das listas de ocorrências...');

    const openList = $('.occurrence-list.open-list');
    const attendanceList = $('.occurrence-list.attendance-list');
    const holdList = $('.occurrence-list.hold-list');

    if (!openList || !attendanceList || !holdList) {
      console.log('⚠️ Nem todas as listas de ocorrências foram encontradas. Pulando reordenação.');
      return false;
    }

    const container = openList.parentElement;
    
    if (!container) {
      console.error('❌ Container das listas não encontrado.');
      return false;
    }

    const lists = [openList, holdList, attendanceList];
    lists.forEach(list => list.remove());

    container.appendChild(openList);
    container.appendChild(holdList);
    container.appendChild(attendanceList);

    console.log('✅ Listas reordenadas: open-list → hold-list → attendance-list');
    return true;
  };

  /**
   * Reorganiza os elementos do dashboard
   */
  const reorganizeDashboard = () => {
    console.log('🔧 Reorganizando elementos do dashboard...');

    const contentLeft = $('.content-fixed.content-left');
    const contentCenterTop = $('.content-fixed.content-center-top');
    const contentRight = $('.content-fixed.content-right');

    if (!contentLeft || !contentCenterTop || !contentRight) {
      console.error('❌ Estrutura esperada não encontrada.');
      return false;
    }

    const leftContent = Array.from(contentLeft.children);
    const centerContent = Array.from(contentCenterTop.children);
    const rightContent = Array.from(contentRight.children);

    contentLeft.innerHTML = '';
    contentCenterTop.innerHTML = '';
    contentRight.innerHTML = '';

    rightContent.forEach(child => contentLeft.appendChild(child));
    leftContent.forEach(child => contentCenterTop.appendChild(child));
    centerContent.forEach(child => contentRight.appendChild(child));

    updatePositionClass(contentLeft, 'content-left', 'temp-class-marker-left');
    updatePositionClass(contentCenterTop, 'content-center-top', 'temp-class-marker-center');
    updatePositionClass(contentRight, 'content-right', 'temp-class-marker-right');

    updatePositionClass(contentLeft, 'temp-class-marker-left', 'content-left');
    updatePositionClass(contentCenterTop, 'temp-class-marker-center', 'content-center-top');
    updatePositionClass(contentRight, 'temp-class-marker-right', 'content-right');

    console.log('✅ Elementos reorganizados com sucesso (eventos preservados).');
    return true;
  };

  /**
   * Restaura o dashboard ao estado original
   */
  const restoreDashboard = () => {
    console.log('🔄 Restaurando dashboard ao estado original...');

    if (state.originalState.elements.size === 0) {
      console.error('❌ Estado original não foi salvo.');
      return false;
    }

    // Restaura cada container
    ['left', 'center', 'right'].forEach(key => {
      const saved = state.originalState.elements.get(key);
      if (!saved) return;

      const { element, children, classes, ngClass } = saved;

      // Limpa e restaura filhos
      element.innerHTML = '';
      children.forEach(child => element.appendChild(child));

      // Restaura classes
      element.className = '';
      classes.forEach(cls => element.classList.add(cls));

      // Restaura ng-class
      if (ngClass) {
        element.setAttribute('ng-class', ngClass);
      }
    });

    // Restaura elementos ocultos
    restoreHiddenElements();

    // Remove CSS customizado
    removeCustomCSS();

    console.log('✅ Dashboard restaurado ao estado original.');
    return true;
  };

  /**
   * Alterna entre estado original e modificado
   */
  const toggleDashboard = () => {
    if (state.isModified) {
      // Retorna ao estado original
      const success = restoreDashboard();
      if (success) {
        state.isModified = false;
        console.log('🔙 Dashboard voltou ao estado original.');
      }
    } else {
      // Aplica modificações
      console.log('🚀 Aplicando modificações...');
      
      if (state.originalState.elements.size === 0) {
        saveOriginalState();
      }

      const success = reorganizeDashboard();
      
      if (success) {
        hideOrRemoveElements();
        injectCustomCSS();
        validateOccurrenceLists();
        reorderOccurrenceLists();
        state.isModified = true;
        console.log('✅ Dashboard modificado.');
      }
    }
  };

  /**
   * Configura o atalho de teclado
   */
  const setupKeyboardShortcut = () => {
    const { ctrl, alt, shift, key } = config.keyboard;
    
    // Exibe o atalho configurado
    const modifiers = [];
    if (ctrl) modifiers.push('Ctrl');
    if (alt) modifiers.push('Alt');
    if (shift) modifiers.push('Shift');
    const shortcut = [...modifiers, key].join('+');
    
    console.log(`⌨️ Atalho configurado: ${shortcut}`);

    document.addEventListener('keydown', (e) => {
      // Verifica se a combinação de teclas corresponde
      const ctrlMatch = ctrl ? e.ctrlKey : !e.ctrlKey;
      const altMatch = alt ? e.altKey : !e.altKey;
      const shiftMatch = shift ? e.shiftKey : !e.shiftKey;
      const keyMatch = e.key.toUpperCase() === key.toUpperCase();

      if (ctrlMatch && altMatch && shiftMatch && keyMatch) {
        e.preventDefault();
        console.log(`⌨️ Atalho ${shortcut} pressionado!`);
        toggleDashboard();
      }
    });
  };

  /** --------------------------
   * 🧠 EXECUÇÃO PRINCIPAL
   * ---------------------------*/
  const main = () => {
    console.log('🚀 Iniciando Dashboard Reorganizer v3.0...');
    console.log('📦 Configurações:', {
      removeElements: config.removeElements,
      selectorsToHide: config.selectorsToHideOrRemove,
      keyboard: `${config.keyboard.ctrl ? 'Ctrl+' : ''}${config.keyboard.alt ? 'Alt+' : ''}${config.keyboard.shift ? 'Shift+' : ''}${config.keyboard.key}`
    });

    // Configura atalho de teclado
    setupKeyboardShortcut();

    // Salva estado original
    saveOriginalState();

    // Aplica modificações inicialmente
    toggleDashboard();

    console.log('✨ Script carregado com sucesso!');
    console.log(`💡 Dica: Pressione o atalho para alternar entre estados.`);
  };

  /** --------------------------
   * 🌍 API GLOBAL (OPCIONAL)
   * ---------------------------*/
  window.toggleDashboard = toggleDashboard;
  window.dashboardState = () => ({
    isModified: state.isModified,
    keyboard: config.keyboard
  });

  /** --------------------------
   * 🚀 INICIALIZAÇÃO
   * ---------------------------*/
  try {
    main();
  } catch (err) {
    console.error('⚠️ Erro ao executar o snippet:', err);
  }
})();
